<html>
<head>
<title>Exercises.ipynb</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #7a7e85;}
.s1 { color: #bcbec4;}
.s2 { color: #cf8e6d;}
.s3 { color: #bcbec4;}
.s4 { color: #2aacb8;}
.s5 { color: #6aab73;}
.ls0 { height: 1px; border-width: 0; color: #43454a; background-color:#43454a}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
Exercises.ipynb</font>
</center></td></tr></table>
<pre><span class="s0">#%% md 
</span><span class="s1"># K-MEANS ALGORITHM <hr class="ls0"></span><span class="s0">#%% md 
</span><span class="s1">This exercise consists of three parts. Finish the first part to get a mark of 3.0; the first two parts for 4.0. Complete all three parts to get 5.0. &lt;br&gt; 
Advanced* and optional - means it is optional and will not affect the grade. <hr class="ls0"></span><span class="s0">#%% md 
</span><span class="s1">## Part 1 <hr class="ls0"></span><span class="s0">#%% 
### SOME IMPORTS</span>
<span class="s2">import </span><span class="s1">common </span><span class="s2">as </span><span class="s1">cm</span>
<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">import </span><span class="s1">matplotlib</span><span class="s3">.</span><span class="s1">pyplot </span><span class="s2">as </span><span class="s1">plt</span><hr class="ls0"><span class="s0">#%% md 
</span><span class="s1">1.1) Complete the following distance function <hr class="ls0"></span><span class="s0">#%% 
</span><span class="s2">import </span><span class="s1">math</span>


<span class="s0"># Computes a Euclidean distance between points A and B (these are vectors, i.e., A[0], A[1], ....)</span>
<span class="s2">def </span><span class="s1">getEuclideanDistance</span><span class="s3">(</span><span class="s1">A</span><span class="s3">, </span><span class="s1">B</span><span class="s3">):</span>
    <span class="s1">dist </span><span class="s3">= </span><span class="s1">math</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">((</span><span class="s1">A</span><span class="s3">[</span><span class="s4">0</span><span class="s3">] - </span><span class="s1">B</span><span class="s3">[</span><span class="s4">0</span><span class="s3">]) ** </span><span class="s4">2 </span><span class="s3">+ (</span><span class="s1">A</span><span class="s3">[</span><span class="s4">1</span><span class="s3">] - </span><span class="s1">B</span><span class="s3">[</span><span class="s4">1</span><span class="s3">]) ** </span><span class="s4">2</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">dist</span>
    
<span class="s0"># Test cases</span>
<span class="s1">tests </span><span class="s3">= [</span>
    <span class="s3">([</span><span class="s4">0.0</span><span class="s3">, </span><span class="s4">0.0</span><span class="s3">], [</span><span class="s4">0.0</span><span class="s3">, </span><span class="s4">1.0</span><span class="s3">], </span><span class="s4">1.0</span><span class="s3">),</span>
    <span class="s3">([</span><span class="s4">0.0</span><span class="s3">, </span><span class="s4">0.0</span><span class="s3">], [</span><span class="s4">1.0</span><span class="s3">, </span><span class="s4">1.0</span><span class="s3">], </span><span class="s1">math</span><span class="s3">.</span><span class="s1">sqrt</span><span class="s3">(</span><span class="s4">2</span><span class="s3">)),</span>
    <span class="s3">([</span><span class="s4">2.0</span><span class="s3">, </span><span class="s4">3.0</span><span class="s3">], [</span><span class="s4">5.0</span><span class="s3">, </span><span class="s4">7.0</span><span class="s3">], </span><span class="s4">5.0</span><span class="s3">)</span>
<span class="s3">]</span>

<span class="s2">for </span><span class="s1">A</span><span class="s3">, </span><span class="s1">B</span><span class="s3">, </span><span class="s1">expected </span><span class="s2">in </span><span class="s1">tests</span><span class="s3">:</span>
    <span class="s1">result </span><span class="s3">= </span><span class="s1">getEuclideanDistance</span><span class="s3">(</span><span class="s1">A</span><span class="s3">, </span><span class="s1">B</span><span class="s3">)</span>
    <span class="s1">print</span><span class="s3">(</span><span class="s5">f&quot;A=</span><span class="s2">{</span><span class="s1">A</span><span class="s2">}</span><span class="s5">, B=</span><span class="s2">{</span><span class="s1">B</span><span class="s2">} </span><span class="s5">-&gt; </span><span class="s2">{</span><span class="s1">result</span><span class="s2">} </span><span class="s5">(expected: </span><span class="s2">{</span><span class="s1">expected</span><span class="s2">}</span><span class="s5">)&quot;</span><span class="s3">)</span>
    <span class="s2">assert </span><span class="s1">math</span><span class="s3">.</span><span class="s1">isclose</span><span class="s3">(</span><span class="s1">result</span><span class="s3">, </span><span class="s1">expected</span><span class="s3">), </span><span class="s5">&quot;Test failed!&quot;</span>

<span class="s1">print</span><span class="s3">(</span><span class="s5">&quot;All tests passed&quot;</span><span class="s3">)</span><hr class="ls0"><span class="s0">#%% md 
</span><span class="s1">1.2) Get test data set &amp; display (data = matrix n x m, n = the number of objects, m = the number of attributes) <hr class="ls0"></span><span class="s0">#%% 
</span><span class="s1">data </span><span class="s3">= </span><span class="s1">cm</span><span class="s3">.</span><span class="s1">getTestDataSet</span><span class="s3">()</span>
<span class="s1">cm</span><span class="s3">.</span><span class="s1">displayDataSet</span><span class="s3">(</span><span class="s1">plt</span><span class="s3">, </span><span class="s1">data</span><span class="s3">) </span><span class="s0">#plt = plot package; see the imports above</span><hr class="ls0"><span class="s0">#%% md 
</span><span class="s1">**How many different clusters (groups) do you see here?** <hr class="ls0"></span><span class="s0">#%% 
</span><span class="s4">4</span><hr class="ls0"><span class="s0">#%% md 
</span><span class="s1">The data for this exercise was generated artificially. You can run the below code to see the &quot;true&quot; group assignment. <hr class="ls0"></span><span class="s0">#%% 
</span><span class="s1">data </span><span class="s3">= </span><span class="s1">cm</span><span class="s3">.</span><span class="s1">getTestDataSet</span><span class="s3">()</span>
<span class="s1">print</span><span class="s3">(</span><span class="s1">data</span><span class="s3">)</span>
<span class="s1">assignments </span><span class="s3">= </span><span class="s1">cm</span><span class="s3">.</span><span class="s1">getTestAssignments</span><span class="s3">() </span><span class="s0">### GET &quot;TRUE&quot; GROUP ASSIGNMENT</span>
<span class="s1">cm</span><span class="s3">.</span><span class="s1">displayDataSet</span><span class="s3">(</span><span class="s1">plt</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">assignments </span><span class="s3">= </span><span class="s1">assignments</span><span class="s3">)</span><hr class="ls0"><span class="s0">#%% md 
</span><span class="s1">1.3) K-Means implementation: Firstly, we need to construct K &quot;centroids&quot;. Each centroid represents one group. For simplicity, initially assume that the centroids are randomly selected from the data set (i.e., clone/copy some K random points from data set). Check numpy.random package. Important: each centroid should be unique (no repetitions, consider a &quot;shuffle&quot; approach). Finish the bolow code. <hr class="ls0"></span><span class="s0">#%% 
</span><span class="s2">from </span><span class="s1">numpy</span><span class="s3">.</span><span class="s1">random </span><span class="s2">import </span><span class="s1">random</span>


<span class="s0">### return a vector of centroids (vectors) [[x1, y1], ..., [xk, yk]]</span>
<span class="s2">def </span><span class="s1">getCentroids</span><span class="s3">(</span><span class="s1">K</span><span class="s3">, </span><span class="s1">data</span><span class="s3">):</span>
    <span class="s1">data </span><span class="s3">= </span><span class="s1">data</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">()</span>
    <span class="s1">np</span><span class="s3">.</span><span class="s1">random</span><span class="s3">.</span><span class="s1">shuffle</span><span class="s3">(</span><span class="s1">data</span><span class="s3">)</span>
    <span class="s1">centroids </span><span class="s3">= </span><span class="s1">data</span><span class="s3">[:</span><span class="s1">K</span><span class="s3">]</span>
    <span class="s2">return </span><span class="s1">centroids</span>

<span class="s1">print</span><span class="s3">(</span><span class="s1">getCentroids</span><span class="s3">(</span><span class="s4">2</span><span class="s3">, </span><span class="s1">data</span><span class="s3">))</span><hr class="ls0"><span class="s0">#%% md 
</span><span class="s1">1.4) Get acquainted with some parameters:  
- DATA - test data set, a vector of  n 2d points: [[x1, y1], ..., [xn, yn]], loaded from common.py 
- M - the number of attributes/dimensions; M = 2 for this exercise, 
- K - expected number of groups, 
- CENTROIDS - initial K centroids; CENTROIDS =  [[x1, y1],...,[xk, yk]], 
- ASSIGNMENTS - data structure representing group assignments; ASSIGNMENTS = [[idx1_1,...,],....,[idx1_K,....]], i.e., i-th element is a vector of indexes of corresponding data points in DATA, being assigned to i-th group. For instance if |DATA| = 3, K = 2, and ASSIGNMENTS = [[0, 2], [1]], it means that DATA[0] and DATA[2] points are assigned to the first group, while DATA[1] point is assigned to the second group. <hr class="ls0"></span><span class="s0">#%% md 
</span><span class="s1">1.5) Finish the below function. It should perform a single step of K-Means algorithm: 
 
a) Firstly, construct new group assignments. For this reason, iterate over all data points. For each (i-th) point, verify its distance to each (k-th) centroid. Check for which centroid the distance is the smallest and update NEW_ASSIGNMENTS adequately (NEW_ASSIGNMENTS[k-th centroid].append(i-th index/data point)). 
 
Important: NO_CHANGE boolean variable should be set to False if the assignments have changed from the previous iteration to the current one (NEW_ASSIGNMENTS != (OLD) ASSIGNMENTS).  
 
b) Update centroids (NEW_CENTROIDS), i.e., compute centers of masses of data points belonging to different groups.  
 
c) Return NO_CHANGE, NEW_ASSIGNMENTS, NEW_CENTROIDS. <hr class="ls0"></span><span class="s0">#%% 
</span><span class="s2">def </span><span class="s1">doKMeansStep</span><span class="s3">(</span><span class="s1">DATA</span><span class="s3">, </span><span class="s1">M</span><span class="s3">, </span><span class="s1">K</span><span class="s3">, </span><span class="s1">CENTROIDS</span><span class="s3">, </span><span class="s1">ASSIGNMENTS</span><span class="s3">):    </span>
    <span class="s1">NO_CHANGE </span><span class="s3">= </span><span class="s2">True</span>
    <span class="s2">if </span><span class="s1">ASSIGNMENTS </span><span class="s2">is None</span><span class="s3">: </span><span class="s1">NO_CHANGE </span><span class="s3">= </span><span class="s2">False</span>
    <span class="s0">#TODO</span>

    
    <span class="s0">### CONSTRUCT NEW ASSIGNMENTS</span>
    <span class="s1">NEW_ASSIGNMENTS </span><span class="s3">= [[] </span><span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">K</span><span class="s3">)]</span>
    <span class="s0">### TODO</span>


    <span class="s2">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">point </span><span class="s2">in </span><span class="s1">enumerate</span><span class="s3">(</span><span class="s1">DATA</span><span class="s3">):</span>
        <span class="s1">dists </span><span class="s3">= []</span>
        <span class="s2">for </span><span class="s1">centroid </span><span class="s2">in </span><span class="s1">CENTROIDS</span><span class="s3">:</span>
            <span class="s1">dists</span><span class="s3">.</span><span class="s1">append</span><span class="s3">(</span><span class="s1">getEuclideanDistance</span><span class="s3">(</span><span class="s1">point</span><span class="s3">, </span><span class="s1">centroid</span><span class="s3">))</span>
        <span class="s1">nearest </span><span class="s3">= </span><span class="s1">dists</span><span class="s3">.</span><span class="s1">index</span><span class="s3">(</span><span class="s1">min</span><span class="s3">(</span><span class="s1">dists</span><span class="s3">))</span>
        <span class="s1">NEW_ASSIGNMENTS</span><span class="s3">[</span><span class="s1">nearest</span><span class="s3">].</span><span class="s1">append</span><span class="s3">(</span><span class="s1">i</span><span class="s3">)</span>

    <span class="s2">if </span><span class="s1">ASSIGNMENTS </span><span class="s3">!= </span><span class="s1">NEW_ASSIGNMENTS</span><span class="s3">:</span>
        <span class="s1">NO_CHANGE </span><span class="s3">= </span><span class="s2">False</span>
    <span class="s2">else</span><span class="s3">:</span>
        <span class="s1">NO_CHANGE </span><span class="s3">= </span><span class="s2">True</span>

    <span class="s0">### CONSTRUCT NEW CENTROIDS</span>
    <span class="s1">NEW_CENTROIDS </span><span class="s3">= []</span>
    <span class="s0">### TODO</span>
    <span class="s2">for </span><span class="s1">assignment </span><span class="s2">in </span><span class="s1">NEW_ASSIGNMENTS</span><span class="s3">:</span>
        <span class="s2">if </span><span class="s1">len</span><span class="s3">(</span><span class="s1">assignment</span><span class="s3">) &gt; </span><span class="s4">0</span><span class="s3">:</span>
            <span class="s1">mean_x </span><span class="s3">= </span><span class="s1">sum</span><span class="s3">(</span><span class="s1">DATA</span><span class="s3">[</span><span class="s1">index</span><span class="s3">][</span><span class="s4">0</span><span class="s3">] </span><span class="s2">for </span><span class="s1">index </span><span class="s2">in </span><span class="s1">assignment</span><span class="s3">) / </span><span class="s1">len</span><span class="s3">(</span><span class="s1">assignment</span><span class="s3">)</span>
            <span class="s1">mean_y </span><span class="s3">= </span><span class="s1">sum</span><span class="s3">(</span><span class="s1">DATA</span><span class="s3">[</span><span class="s1">index</span><span class="s3">][</span><span class="s4">1</span><span class="s3">]  </span><span class="s2">for </span><span class="s1">index </span><span class="s2">in </span><span class="s1">assignment</span><span class="s3">) / </span><span class="s1">len</span><span class="s3">(</span><span class="s1">assignment</span><span class="s3">)</span>
            <span class="s1">NEW_CENTROIDS</span><span class="s3">.</span><span class="s1">append</span><span class="s3">([</span><span class="s1">mean_x</span><span class="s3">, </span><span class="s1">mean_y</span><span class="s3">])</span>
    
    <span class="s2">return </span><span class="s1">NO_CHANGE</span><span class="s3">, </span><span class="s1">NEW_CENTROIDS</span><span class="s3">, </span><span class="s1">NEW_ASSIGNMENTS </span><hr class="ls0"><span class="s0">#%% md 
</span><span class="s1">1.6) The below code performs 1 iteration of K-Menas algorithm for K=2 and the test data set. Check the results (notice that centroids are marked with squares). <hr class="ls0"></span><span class="s0">#%% 
</span><span class="s1">DATA </span><span class="s3">= </span><span class="s1">cm</span><span class="s3">.</span><span class="s1">getTestDataSet</span><span class="s3">()</span>
<span class="s1">CENTROIDS </span><span class="s3">= </span><span class="s1">getCentroids</span><span class="s3">(</span><span class="s4">2</span><span class="s3">, </span><span class="s1">DATA</span><span class="s3">)</span>
<span class="s1">NO_CHANGE</span><span class="s3">, </span><span class="s1">CENTROIDS</span><span class="s3">, </span><span class="s1">ASSIGNMENTS </span><span class="s3">= </span><span class="s1">doKMeansStep</span><span class="s3">(</span><span class="s1">DATA</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s1">CENTROIDS</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">(), </span><span class="s2">None</span><span class="s3">)</span>
<span class="s1">print</span><span class="s3">(</span><span class="s1">NO_CHANGE</span><span class="s3">)</span>
<span class="s1">cm</span><span class="s3">.</span><span class="s1">displayDataSet</span><span class="s3">(</span><span class="s1">plt</span><span class="s3">, </span><span class="s1">DATA</span><span class="s3">, </span><span class="s1">assignments </span><span class="s3">= </span><span class="s1">ASSIGNMENTS</span><span class="s3">, </span><span class="s1">centroids </span><span class="s3">= </span><span class="s1">CENTROIDS</span><span class="s3">)</span><hr class="ls0"><span class="s0">#%% md 
</span><span class="s1">1.7) Complete the below piece of code. The doKMeans function should perform 100 steps of K-Means algorithm. However, the loop should be stopped when the NO_CHANGE variable = True. It that is so, **print the information on after how many iterations the process has stopped**. Lastly, use cm.displayDataSet to depict the final groups.  
 
(Advanced*): make an animation showing the steps of the K-means algorithm. It is easier to do in jupyter notebook. 
https://matplotlib.org/3.3.2/api/animation_api.html 
http://louistiao.me/posts/notebooks/embedding-matplotlib-animations-in-jupyter-notebooks/ <hr class="ls0"></span><span class="s0">#%% 
</span><span class="s2">def </span><span class="s1">doKMeans</span><span class="s3">(</span><span class="s1">DATA</span><span class="s3">, </span><span class="s1">CENTROIDS</span><span class="s3">, </span><span class="s1">K </span><span class="s3">= </span><span class="s4">2</span><span class="s3">, </span><span class="s1">M </span><span class="s3">= </span><span class="s4">2</span><span class="s3">, </span><span class="s1">display </span><span class="s3">= </span><span class="s2">True</span><span class="s3">):</span>
    <span class="s1">ASSIGNMENTS </span><span class="s3">= [[] </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">K</span><span class="s3">)]</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s4">100</span><span class="s3">):</span>
        <span class="s1">NO_CHANGE</span><span class="s3">, </span><span class="s1">CENTROIDS</span><span class="s3">, </span><span class="s1">ASSIGNMENTS </span><span class="s3">= </span><span class="s1">doKMeansStep</span><span class="s3">(</span><span class="s1">DATA</span><span class="s3">, </span><span class="s1">M</span><span class="s3">, </span><span class="s1">K</span><span class="s3">, </span><span class="s1">CENTROIDS</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">(), </span><span class="s1">ASSIGNMENTS</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">NO_CHANGE </span><span class="s2">is True</span><span class="s3">:</span>
            <span class="s1">print</span><span class="s3">(</span><span class="s5">&quot;For K = &quot;</span><span class="s3">, </span><span class="s1">K</span><span class="s3">, </span><span class="s5">&quot;, &quot;</span><span class="s3">, </span><span class="s1">i</span><span class="s3">, </span><span class="s5">&quot; iterations are needed&quot;</span><span class="s3">)</span>
            <span class="s2">break</span>
        
    <span class="s2">return </span><span class="s1">DATA</span><span class="s3">, </span><span class="s1">CENTROIDS</span><span class="s3">, </span><span class="s1">ASSIGNMENTS   </span>

<span class="s1">DATA </span><span class="s3">= </span><span class="s1">cm</span><span class="s3">.</span><span class="s1">getTestDataSet</span><span class="s3">()</span>
<span class="s1">CENTROIDS </span><span class="s3">= </span><span class="s1">getCentroids</span><span class="s3">(</span><span class="s4">2</span><span class="s3">, </span><span class="s1">DATA</span><span class="s3">)</span>
<span class="s1">DATA</span><span class="s3">, </span><span class="s1">CENTROIDS</span><span class="s3">, </span><span class="s1">ASSIGNMENTS </span><span class="s3">= </span><span class="s1">doKMeans</span><span class="s3">(</span><span class="s1">DATA</span><span class="s3">, </span><span class="s1">CENTROIDS</span><span class="s3">, </span><span class="s1">K </span><span class="s3">= </span><span class="s4">2</span><span class="s3">)</span><hr class="ls0"><span class="s0">#%% md 
</span><span class="s1">1.8) Run the below piece of code and observe the results. Which K seems to be the best choice? <hr class="ls0"></span><span class="s0">#%% 
</span><span class="s1">DATA </span><span class="s3">= </span><span class="s1">cm</span><span class="s3">.</span><span class="s1">getTestDataSet</span><span class="s3">()</span>
<span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s4">2</span><span class="s3">, </span><span class="s4">11</span><span class="s3">):</span>
    <span class="s1">CENTROIDS </span><span class="s3">= </span><span class="s1">getCentroids</span><span class="s3">(</span><span class="s1">k</span><span class="s3">, </span><span class="s1">DATA</span><span class="s3">)</span>
    <span class="s1">DATA</span><span class="s3">, </span><span class="s1">NEW_CENTROIDS</span><span class="s3">, </span><span class="s1">NEW_ASSIGNMENTS </span><span class="s3">= </span><span class="s1">doKMeans</span><span class="s3">(</span><span class="s1">DATA</span><span class="s3">, </span><span class="s1">CENTROIDS</span><span class="s3">, </span><span class="s1">K </span><span class="s3">= </span><span class="s1">k</span><span class="s3">)</span><hr class="ls0"><span class="s0">#%% md 
</span><span class="s1">## Part 2 <hr class="ls0"></span><span class="s0">#%% md 
</span><span class="s1">The quality of final group assignment can be assessed in various ways. In this exercise, you are asked to compute a total (sum) distance between data points and their cluster centroids for different values of K. Obviously, it is expected that such indicator will always decrese with the increase of K. But, obviously, $K=\infty$ is not the best option. However, there exsits some threshold K' such that for each K'' &gt; K' the decrease will not be significant. This threshold is called an &quot;elbow&quot; and its corresponding K value is considered satisfactory. Firstly, complete the below function. It should compute the total (sum) distance between data points and their cluster centroids. Secondly, compute the the total distances for final clusters for for $K\in [2, 10]$. Then, plot the results. Use cm.displayResults(plt, results), where results takes the follwoing form: [[2, result for K = 2], [3, result for K = 3], ..., [10, result for K = 10]]. **Find the &quot;elbow&quot;**. <hr class="ls0"></span><span class="s0">#%% 
</span><span class="s2">def </span><span class="s1">getTotalDistance</span><span class="s3">(</span><span class="s1">DATA</span><span class="s3">, </span><span class="s1">CENTROIDS</span><span class="s3">, </span><span class="s1">ASSIGNMENTS</span><span class="s3">):</span>
    <span class="s1">total </span><span class="s3">= </span><span class="s4">0.0</span>
    <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">len</span><span class="s3">(</span><span class="s1">CENTROIDS</span><span class="s3">)):</span>
        <span class="s1">centroid </span><span class="s3">= </span><span class="s1">CENTROIDS</span><span class="s3">[</span><span class="s1">k</span><span class="s3">]</span>
        <span class="s1">indices </span><span class="s3">= </span><span class="s1">ASSIGNMENTS</span><span class="s3">[</span><span class="s1">k</span><span class="s3">]</span>
        <span class="s2">for </span><span class="s1">idx </span><span class="s2">in </span><span class="s1">indices</span><span class="s3">:</span>
            <span class="s1">point </span><span class="s3">= </span><span class="s1">DATA</span><span class="s3">[</span><span class="s1">idx</span><span class="s3">]</span>
            <span class="s1">total </span><span class="s3">+= </span><span class="s1">getEuclideanDistance</span><span class="s3">(</span><span class="s1">point</span><span class="s3">, </span><span class="s1">centroid</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">total</span>
<hr class="ls0"><span class="s0">#%% 
### PERFORM THE ANALYSIS HERE</span>
<span class="s1">DATA </span><span class="s3">= </span><span class="s1">cm</span><span class="s3">.</span><span class="s1">getTestDataSet</span><span class="s3">()</span>
<span class="s1">results </span><span class="s3">= []</span>

<span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s4">2</span><span class="s3">, </span><span class="s4">10</span><span class="s3">+</span><span class="s4">1</span><span class="s3">):</span>
    <span class="s1">CENTS </span><span class="s3">= </span><span class="s1">getCentroids</span><span class="s3">(</span><span class="s1">k</span><span class="s3">, </span><span class="s1">DATA</span><span class="s3">)</span>
    <span class="s1">DATA_F</span><span class="s3">, </span><span class="s1">CENT_F</span><span class="s3">, </span><span class="s1">ASSGN_F </span><span class="s3">= </span><span class="s1">doKMeans</span><span class="s3">(</span><span class="s1">DATA</span><span class="s3">, </span><span class="s1">CENTS</span><span class="s3">, </span><span class="s1">K </span><span class="s3">= </span><span class="s1">k</span><span class="s3">)</span>
    <span class="s1">dist </span><span class="s3">= </span><span class="s1">getTotalDistance</span><span class="s3">(</span><span class="s1">DATA_F</span><span class="s3">, </span><span class="s1">CENT_F</span><span class="s3">, </span><span class="s1">ASSGN_F</span><span class="s3">)</span>
    <span class="s1">results</span><span class="s3">.</span><span class="s1">append</span><span class="s3">([</span><span class="s1">k</span><span class="s3">, </span><span class="s1">dist</span><span class="s3">])</span>

<span class="s1">cm</span><span class="s3">.</span><span class="s1">displayResults</span><span class="s3">(</span><span class="s1">plt</span><span class="s3">, </span><span class="s1">results</span><span class="s3">)</span><hr class="ls0"><span class="s0">#%% md 
</span><span class="s1"># Part 3 - a small case study <hr class="ls0"></span><span class="s0">#%% md 
</span><span class="s1">In this exercise you are asked to use the K-Means algorithm to cluster some data provided in cm.getCaseDataSet() (important note, this data was generated artificially - this is not real-world data). This data contains information on 250 persons. Each person is characterized with the following attributes: 
 
a) Age &lt;br&gt; 
b) Salary (z≈Ç) &lt;br&gt;  
c) Health index (0-100; 0 = worst health, 100 = best health) &lt;br&gt; 
d) Time spent in school or work (hours) &lt;br&gt; 
e) Time spent on sport activities (hours) &lt;br&gt; 
 
Follow these steps: 
1. Load the data.  
2. Check the min and max values for each attribute and consider normalization.  
3. Run K-Means algorithm (use the pieces of code you completed in previous exercises) for different K.  
4. Identify the best K using the performance indicator introduced in Part 2.  
5. For the best K - analyze constructed clusters.  
    * Compute basic stats (mean, max, min and standard deviation) attribute values within each cluster. You should use centroids constructed in the final iteration.  
    * (optional) Generate distribution plots.  
    * (optional) Calculate the internal consistency of clusters by calculating basic stats (mean, max, min and standard deviation) of distance between each pair of objects in each cluster and visualize this data. 
    * (optional) Compute basic stats (mean, max, min and standard deviation) of distance between each pair of clusters and visualize this data. 
    * You can print these values / show pandas DataFrame / visualize them with matplotlib boxplot (optional).  
    * Values should be presented in a non-normalized version. 
6. Using the above, briefly describe each cluster. <hr class="ls0"></span><span class="s0">#%% 
</span><span class="s1">DATA </span><span class="s3">= </span><span class="s1">cm</span><span class="s3">.</span><span class="s1">getCaseDataSet</span><span class="s3">()</span>
<span class="s1">print</span><span class="s3">(</span><span class="s1">DATA</span><span class="s3">[:</span><span class="s4">5</span><span class="s3">])</span>
<hr class="ls0"><span class="s0">#%% 
### CONSIDER NORMALIZATION HERE</span>
<span class="s2">def </span><span class="s1">normalizeData</span><span class="s3">(</span><span class="s1">DATA</span><span class="s3">):</span>
    <span class="s1">DATA </span><span class="s3">= </span><span class="s1">np</span><span class="s3">.</span><span class="s1">array</span><span class="s3">(</span><span class="s1">DATA</span><span class="s3">, </span><span class="s1">float</span><span class="s3">)</span>
    <span class="s1">mins </span><span class="s3">= </span><span class="s1">DATA</span><span class="s3">.</span><span class="s1">min</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">=</span><span class="s4">0</span><span class="s3">)</span>
    <span class="s1">maxs </span><span class="s3">= </span><span class="s1">DATA</span><span class="s3">.</span><span class="s1">max</span><span class="s3">(</span><span class="s1">axis</span><span class="s3">=</span><span class="s4">0</span><span class="s3">)</span>
    <span class="s1">norm </span><span class="s3">= (</span><span class="s1">DATA </span><span class="s3">- </span><span class="s1">mins</span><span class="s3">) / (</span><span class="s1">maxs </span><span class="s3">- </span><span class="s1">mins</span><span class="s3">)</span>
    <span class="s2">return </span><span class="s1">norm</span><span class="s3">, </span><span class="s1">mins</span><span class="s3">, </span><span class="s1">maxs</span>

<span class="s1">DATA_N</span><span class="s3">, </span><span class="s1">mins</span><span class="s3">, </span><span class="s1">maxs </span><span class="s3">= </span><span class="s1">normalizeData</span><span class="s3">(</span><span class="s1">DATA</span><span class="s3">)</span><hr class="ls0"><span class="s0">#%% 
</span><span class="s2">def </span><span class="s1">doKMeans_CaseStudy</span><span class="s3">(</span><span class="s1">DATA</span><span class="s3">, </span><span class="s1">K </span><span class="s3">= </span><span class="s4">2</span><span class="s3">, </span><span class="s1">M </span><span class="s3">= </span><span class="s4">5</span><span class="s3">):</span>
    <span class="s1">CENTROIDS </span><span class="s3">= </span><span class="s1">getCentroids</span><span class="s3">(</span><span class="s1">K</span><span class="s3">, </span><span class="s1">DATA</span><span class="s3">) </span><span class="s0"># GET CENTOIDS</span>
    <span class="s1">ASSIGNMENTS </span><span class="s3">= [[] </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">K</span><span class="s3">)] </span><span class="s0">#</span>
    <span class="s2">for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s4">100</span><span class="s3">):</span>
        <span class="s1">NO_CHANGE</span><span class="s3">, </span><span class="s1">CENTROIDS</span><span class="s3">, </span><span class="s1">ASSIGNMENTS </span><span class="s3">= </span><span class="s1">doKMeansStep</span><span class="s3">(</span><span class="s1">DATA</span><span class="s3">, </span><span class="s1">M</span><span class="s3">, </span><span class="s1">K</span><span class="s3">, </span><span class="s1">CENTROIDS</span><span class="s3">.</span><span class="s1">copy</span><span class="s3">(), </span><span class="s1">ASSIGNMENTS</span><span class="s3">)</span>
        <span class="s2">if </span><span class="s1">NO_CHANGE </span><span class="s2">is True</span><span class="s3">:</span>
            <span class="s2">break</span>

    <span class="s2">return </span><span class="s1">DATA</span><span class="s3">, </span><span class="s1">CENTROIDS</span><span class="s3">, </span><span class="s1">ASSIGNMENTS</span>

<span class="s1">DATA_N</span><span class="s3">, </span><span class="s1">CENTROIDS</span><span class="s3">, </span><span class="s1">ASSIGNMENTS </span><span class="s3">= </span><span class="s1">doKMeans_CaseStudy</span><span class="s3">(</span><span class="s1">DATA_N</span><span class="s3">, </span><span class="s1">K </span><span class="s3">= </span><span class="s4">2</span><span class="s3">)</span><hr class="ls0"><span class="s0">#%% 
### DO THE ANALYSIS HERE (FIND ELBOW)</span>
<span class="s1">results_case </span><span class="s3">= []</span>

<span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s4">2</span><span class="s3">, </span><span class="s4">11</span><span class="s3">):</span>
    <span class="s1">DATA_F</span><span class="s3">, </span><span class="s1">CENT_F</span><span class="s3">, </span><span class="s1">ASSGN_F </span><span class="s3">= </span><span class="s1">doKMeans_CaseStudy</span><span class="s3">(</span><span class="s1">DATA_N</span><span class="s3">, </span><span class="s1">K</span><span class="s3">=</span><span class="s1">k</span><span class="s3">, </span><span class="s1">M</span><span class="s3">=</span><span class="s4">5</span><span class="s3">)</span>
    <span class="s1">d </span><span class="s3">= </span><span class="s1">getTotalDistance</span><span class="s3">(</span><span class="s1">DATA_F</span><span class="s3">, </span><span class="s1">CENT_F</span><span class="s3">, </span><span class="s1">ASSGN_F</span><span class="s3">)</span>
    <span class="s1">results_case</span><span class="s3">.</span><span class="s1">append</span><span class="s3">([</span><span class="s1">k</span><span class="s3">, </span><span class="s1">d</span><span class="s3">])</span>

<span class="s1">cm</span><span class="s3">.</span><span class="s1">displayResults</span><span class="s3">(</span><span class="s1">plt</span><span class="s3">, </span><span class="s1">results_case</span><span class="s3">)</span><hr class="ls0"><span class="s0">#%% md 
</span><span class="s1">**Characterize the data in clusters generated by K-means run for suitably adjusted K** <hr class="ls0"></span><span class="s0">#%% 
### DISPLAY - SUMMARIZE - STATS FOR THE BEST K FOUND IN THE PREVIOUS STEP</span>
<span class="s1">bestK </span><span class="s3">= </span><span class="s4">3</span>
<span class="s1">DATA_F</span><span class="s3">, </span><span class="s1">CENT_F</span><span class="s3">, </span><span class="s1">ASSGN_F </span><span class="s3">= </span><span class="s1">doKMeans_CaseStudy</span><span class="s3">(</span><span class="s1">DATA_N</span><span class="s3">, </span><span class="s1">K</span><span class="s3">=</span><span class="s1">bestK</span><span class="s3">, </span><span class="s1">M</span><span class="s3">=</span><span class="s4">5</span><span class="s3">)</span>
<hr class="ls0"><span class="s0">#%% 
</span><span class="s2">import </span><span class="s1">statistics </span><span class="s2">as </span><span class="s1">st</span>

<span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s1">bestK</span><span class="s3">):</span>
    <span class="s1">print</span><span class="s3">(</span><span class="s5">&quot;</span><span class="s2">\n</span><span class="s5">Cluster&quot;</span><span class="s3">, </span><span class="s1">k</span><span class="s3">+</span><span class="s4">1</span><span class="s3">)</span>
    <span class="s1">idxs </span><span class="s3">= </span><span class="s1">ASSGN_F</span><span class="s3">[</span><span class="s1">k</span><span class="s3">]</span>
    <span class="s1">cluster </span><span class="s3">= [</span><span class="s1">DATA</span><span class="s3">[</span><span class="s1">i</span><span class="s3">] </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">idxs</span><span class="s3">]</span>

    <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range</span><span class="s3">(</span><span class="s4">5</span><span class="s3">):</span>
        <span class="s1">vals </span><span class="s3">= [</span><span class="s1">obj</span><span class="s3">[</span><span class="s1">j</span><span class="s3">] </span><span class="s2">for </span><span class="s1">obj </span><span class="s2">in </span><span class="s1">cluster</span><span class="s3">]</span>
        <span class="s1">print</span><span class="s3">(</span>
            <span class="s5">f&quot;Attr </span><span class="s2">{</span><span class="s1">j</span><span class="s2">}</span><span class="s5">:&quot;</span><span class="s3">,</span>
            <span class="s5">&quot;min=&quot;</span><span class="s3">, </span><span class="s1">min</span><span class="s3">(</span><span class="s1">vals</span><span class="s3">),</span>
            <span class="s5">&quot;max=&quot;</span><span class="s3">, </span><span class="s1">max</span><span class="s3">(</span><span class="s1">vals</span><span class="s3">),</span>
            <span class="s5">&quot;mean=&quot;</span><span class="s3">, </span><span class="s1">sum</span><span class="s3">(</span><span class="s1">vals</span><span class="s3">)/</span><span class="s1">len</span><span class="s3">(</span><span class="s1">vals</span><span class="s3">),</span>
            <span class="s5">&quot;std=&quot;</span><span class="s3">, </span><span class="s1">st</span><span class="s3">.</span><span class="s1">pstdev</span><span class="s3">(</span><span class="s1">vals</span><span class="s3">)</span>
        <span class="s3">)</span></pre>
</body>
</html>